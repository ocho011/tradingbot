"""
Base trading strategy interface.

All trading strategies should inherit from this base class.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

from src.core.constants import PositionSide


@dataclass
class TradingSignal:
    """Trading signal generated by a strategy."""

    strategy_name: str
    timestamp: datetime
    entry_price: float
    direction: PositionSide
    confidence: float  # 0.0 to 1.0
    stop_loss: float
    take_profit: float
    timeframe_analysis: dict  # Details from each timeframe
    metadata: dict = None  # Additional strategy-specific data

    def __post_init__(self):
        """Validate signal data."""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Confidence must be between 0.0 and 1.0, got {self.confidence}")

        if self.metadata is None:
            self.metadata = {}


class BaseStrategy(ABC):
    """
    Base class for all trading strategies.

    Strategies analyze multi-timeframe market data and generate trading signals.
    """

    def __init__(self, name: str):
        """
        Initialize strategy.

        Args:
            name: Strategy identifier
        """
        self.name = name
        self._enabled = True

    @property
    def enabled(self) -> bool:
        """Check if strategy is enabled."""
        return self._enabled

    def enable(self):
        """Enable the strategy."""
        self._enabled = True

    def disable(self):
        """Disable the strategy."""
        self._enabled = False

    @abstractmethod
    def analyze(self, market_data: dict) -> Optional[TradingSignal]:
        """
        Analyze market data and generate trading signal.

        Args:
            market_data: Dictionary containing multi-timeframe market data and indicators

        Returns:
            TradingSignal if conditions are met, None otherwise
        """

    @abstractmethod
    def validate_signal(self, signal: TradingSignal) -> bool:
        """
        Validate a generated signal before execution.

        Args:
            signal: The trading signal to validate

        Returns:
            True if signal is valid, False otherwise
        """

    def calculate_stop_loss(
        self, entry_price: float, direction: PositionSide, reference_level: float
    ) -> float:
        """
        Calculate stop loss price.

        Args:
            entry_price: Entry price for the trade
            direction: Trade direction (LONG/SHORT)
            reference_level: Reference price level (e.g., recent low/high)

        Returns:
            Stop loss price
        """
        if direction == PositionSide.LONG:
            # For long, stop below reference level
            return reference_level * 0.998  # 0.2% buffer
        else:
            # For short, stop above reference level
            return reference_level * 1.002  # 0.2% buffer

    def calculate_take_profit(
        self, entry_price: float, stop_loss: float, risk_reward_ratio: float = 2.0
    ) -> float:
        """
        Calculate take profit price based on risk-reward ratio.

        Args:
            entry_price: Entry price for the trade
            stop_loss: Stop loss price
            risk_reward_ratio: Desired risk-reward ratio (default 2:1)

        Returns:
            Take profit price
        """
        risk = abs(entry_price - stop_loss)
        reward = risk * risk_reward_ratio

        if entry_price > stop_loss:  # LONG position
            return entry_price + reward
        else:  # SHORT position
            return entry_price - reward
